엔티티 클래스

1. @Id -> pk 로 사용이됨.
2. 클래스를 생성하면, 스프링이 실행시, 데이터베이스에 DDL 로써 바로 반영.
(조건, ddl-auto= none, create, create-drop. validate, update,)

3. 애너테이션을 이용해서, 테이블 만들 때, 컬럼들의 조건, 조인, 연관관계 매핑.

기존에 개념상, VO(Value Object) 클래스 대신에 , Entity Class 가 자리 매김.
영향력이 커짐, 테이블도 직접 생성함.

엔티티 클래스에서, 자동번호 증가 정책 옵션
  // pk 숫자를 자동 증가를 어떤 방식으로 하겠니? 해당 마리아 디비에서 사용하는 증가 번호 정책을 이용하겠습니다.

1  보통은, 해당 디비의 정책을 준수한다.
  @GeneratedValue(strategy= GenerationType.IDENTITY)
: 각각의 데이터베이스에 존재하는 증가 정책을 이용

2 strategy= GenerationType.AUTO
: 부트가 알아서 자동으로 설정. (방언, 사투리, 기존 표준 SQL 외의 데이터베이스를 가리킬 때 사용. )

3 strategy= GenerationType.SEQUENCE
: 오라클 적용, 시퀀스 순서 테이블을 만들어서, 따로 작용.

4 strategy= GenerationType.TABLE
: 테이블을 만들어서 사용함.



엔티티 클래스에서, 공통으로 사용하는 , 등록시간, 수정시간 이용시.
추상 클래스에서 auditing 추가 기능 리스너 이용시.
메인 메서드에서, 애너테이션 활성화가 필요.
예시
@EnableJpaAuditing
public class Boot501Application {

추상 클래스에서 이용시에는 사용하겠다라는 의미로
@EntityListeners(value = {AuditingEntityListener.class})

결과는, board 테이블에서, 2개의 필드가 추가됨.



테이블 생성시,
각 컬럼에 조건을 설정.
예) varchar2 (2000) not null
default
unique

엔티티 클래스 -> 테이블에 반영.
쿼리 메서드 이용해서, 기본 crud 확인 했음.


페이징 관련, 부트에서는 페이징 관련 인터페이스를 따로 만들어서
좀 더 쉽게 구현 가능함.
페이징 준비물)
1) 페이지
2) 한 페이징당 보여줄 갯수
3) 전체 갯수
4) 디비에서 나눠진 목록

Pageable 인터페이스 이용. -> 리턴 타입 : Page 타입을 반환 받음.
페이징 준비물 도구 : PageRequest
예시)
PageRequest.of(페이지번호, 사이즈크기, 정렬기준)
PageRequest.of(0, 10, 오름,내림)







